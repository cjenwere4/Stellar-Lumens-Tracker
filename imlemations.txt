
My implemenatations
def my_factorial(n: int):
    if (n == 1 or n == 0):
        return 1
    n *= my_factorial(n-1)
    return n

def my_factorial(n: int):
    if (n == 1 or n == 0):
        return 1
    val = 1
    while (n > 1):
        val *= n
        n-=1
    return val

def my_reduce(func, iter_list, seed) :
    val = seed # this must be the starting point for val because that's what the user set
    for v in iter(iter_list): # iterate through all the values of the set
        val = func(val, v) # execute the function on val <op> v, the other way around yield the wrong results
    return val #return val, in the case that function isn't even a function it will just go straight this


----------------------------------DOWNING'S IMPLEMENTATION, STUDY IT LIVE BY IT-----------------------------
# 467 milliseconds
class map_iterator (Iterator[T]) :
    def __init__ (self, uf: Callable[[T], T], a: Iterable[T]) -> None :
        self.uf = uf
        self.p  = iter(a)

    def __iter__ (self) -> Iterator[T] :
        return self

    def __next__ (self) -> T :
        return self.uf(next(self.p))

# 318 milliseconds
def map_for (uf: Callable[[T], T], a: Iterable[T]) -> Iterator[T] :
    for v in a :
        yield uf(v)

# 320 milliseconds
def map_generator (uf: Callable[[T], T], a: Iterable[T]) -> Iterator[T] :
    return (uf(v) for v in a)
